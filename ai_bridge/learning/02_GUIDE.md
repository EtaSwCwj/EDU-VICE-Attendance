# 2실린더 자동화 시스템 가이드

> **버전**: v8.1 (2025-12-28)
> **마지막 업데이트**: 컨텍스트 관리 규칙 추가 (Sonnet 분할 작업, /compact)

---

## 🔥 핵심 컨셉

**"Opus는 관리자, Sonnet은 실행자"**

```
CP: 복붙 1번
      ↓
Opus (Manager): 분석 → 스몰스텝 분해 → Sonnet 호출 → 검증
      ↓
Sonnet (Worker): 실제 작업 실행 → 텍스트 보고
      ↓
Opus: 로그 저장 → 최종 보고서 파일 작성
```

---

## 📐 시스템 구조 (v7.2)

### 역할 분담

| 역할 | 모델 | 담당 |
|------|------|------|
| Manager | Opus | 분석, 분해, 검증, **로그 저장**, **보고서 파일 작성** |
| Worker | Sonnet | 작업 실행, **텍스트 보고만** |

### 보고서 중복 방지

- Sonnet: 결과를 텍스트로만 보고 (파일 X)
- Opus: 로그 저장 + 최종 보고서만 파일로 작성

---

## 🆕 Sonnet 로그 저장 (v7.2)

### 왜 필요?
- Opus가 Sonnet 결과를 텍스트로만 받으면 **컨텍스트 손실**
- 나중에 디버깅할 때 로그 필요

### 규칙
| 항목 | 값 |
|------|-----|
| 저장 위치 | `ai_bridge/logs/` |
| 파일명 | `big_XXX_step_YY.log` |
| 작성자 | Opus (Sonnet 결과 받아서 저장) |

---

## 🚀 사용법

### 수동 모드 실행

```bash
npm run claude:opus
# 빅스텝 명령어 복붙 → Opus가 Sonnet 부려서 작업 → "테스트 종료"
```

### Sonnet 호출 (Opus가 사용)

```bash
claude --model claude-sonnet-4-20250514 --dangerously-skip-permissions -p "스몰스텝 내용"
```

---

## 🔄 듀얼 디버깅 (Sonnet 동시 호출)

### 왜 동시 호출?

```
❌ 순차 호출:
Opus → Sonnet 1 (폰 빌드) → 완료 대기... → Sonnet 2 (웹 빌드)
                              ↑ 블로킹!

✅ 동시 호출:
Opus → Sonnet 1 (폰 빌드) ─┐
     → Sonnet 2 (웹 빌드) ─┴→ 병렬 실행!
```

각 `claude` 명령은 별도 프로세스라서 블로킹 안 됨!

### 플로우

```
1. Opus: Sonnet 호출 (디바이스 확인) → 완료 대기
2. Opus: Sonnet 2개 동시 호출
   - Sonnet 1: flutter run -d phone
   - Sonnet 2: flutter run -d chrome --web-port=8080
3. Opus: 각 Sonnet 결과 로그 저장
4. Opus: 두 Sonnet 결과 검증
5. Opus: CP 명령 대기 ("테스트 종료" 등)
6. Opus: 보고서 작성
```

---

## 📁 폴더 구조

```
ai_bridge/
├── learning/              # 학습 데이터
│   ├── GUIDE.md           # 시스템 가이드 (이 파일)
│   ├── PRINCIPLES.md      # 핵심 원칙
│   ├── HISTORY.md         # 히스토리
│   ├── PATTERNS.md        # 패턴
│   └── WORKFLOW.md        # 워크플로우 상세
│
├── templates/             # 템플릿 (지시서 작성 전 필수 읽기!)
│   └── BIGSTEP_TEMPLATE.md # 빅스텝 지시서 템플릿
│
├── bigstep/               # 작업 지시서
│   └── BIG_XXX_제목.md
│
├── logs/                  # Sonnet 실행 로그 (v7.2)
│   └── big_XXX_step_YY.log
│
└── report/                # 보고서 (Opus만 작성)
    └── big_XXX_report.md
```

---

## 💻 npm scripts

| 명령어 | 설명 |
|--------|------|
| `npm run claude:opus` | Opus CLI (Manager 역할) |

---

## 🎯 중간 명령어 (CP → Opus)

| 명령어 | 동작 |
|--------|------|
| 테스트 종료 | 보고서 작성 + 종료 |
| 로그 확인 | Sonnet 시켜서 로그 출력 |
| 이거 고쳐줘 | Sonnet 시켜서 수정 |

---

## ⚠️ 핵심 규칙

### Opus (Manager)
- 직접 작업 금지 → Sonnet 시킬 것
- Sonnet 결과 반드시 검증
- **Sonnet 결과 로그 파일로 저장**
- **보고서 파일은 Opus만 작성**
- CP 명령 없이 임의 종료 금지

### Sonnet (Worker)
- 작업 실행 + **텍스트 보고만**
- 보고서 파일 생성 금지
- --dangerously-skip-permissions로 권한 안 물음

---

## 📝 지시서 작성 규칙 (Desktop Opus용)

### ⚠️ 지시서 작성 전 필수 프로세스

**이 순서 무조건 따를 것!**

```
1. ai_bridge/templates/BIGSTEP_TEMPLATE.md 읽기
2. 로컬 코드 확인 (view 도구로 실제 파일 열기)
3. 템플릿 체크리스트 채우기
4. 그 다음 지시서 작성
```

템플릿 안 읽고 지시서 쓰면 또 실수한다!

### 1. 구체적인 지시 (필수!)

```
❌ 나쁜 예:
"GraphQL로 변경해"
"버튼 추가해"

✅ 좋은 예:
"659줄 근처 `await Amplify.DataStore.save(invitation);` 삭제하고
아래 GraphQL mutation 코드로 교체:
[구체적인 코드 제공]"
```

**지시서 작성 전 반드시:**
- 로컬 파일 확인 (줄 번호, 기존 코드)
- 삭제할 코드 vs 추가할 코드 명시
- 모호한 표현 금지

### 2. 빌드 필요 여부 판단

| 상황 | 빌드 | 이유 |
|------|------|------|
| 코드 수정만 | ❌ 불필요 | analyze만 하면 됨 |
| UI 확인 필요 | ✅ 폰 단독 | 화면 보면서 확인 |
| 2개 계정 필요 | ✅ 듀얼 | 폰 + 웹 동시 |
| 플랫폼별 테스트 | ✅ 듀얼 | 폰 + 웹 각각 확인 |

### 3. 빌드 형태 결정

```
질문: "이 테스트에 몇 개 계정/기기가 필요한가?"

1개 → 폰 단독 빌드
2개 → 듀얼 빌드 (폰 + 웹)
```

**예시:**
- 로그인 테스트 → 폰 단독
- 초대 시스템 (초대자 + 피초대자) → 듀얼
- QR 스캔 (QR 표시 + 스캔) → 듀얼

### 4. 지시서 체크리스트

지시서 작성 전 확인:

**기본 확인**
- [ ] 로컬 코드 확인했나?
- [ ] 수정할 파일/줄 번호 특정했나?
- [ ] 삭제/추가 코드 구체적으로 썼나?
- [ ] **새 함수/로직에 safePrint 로그 추가했나?**

**테스트 환경**
- [ ] 테스트 계정 리셋 필요?
- [ ] **테스트 계정 현재 상태 확인했나?** (이전 테스트로 오염)
- [ ] 빌드 필요 여부 판단했나?
- [ ] 듀얼 필요 여부 판단했나?

**플로우 확인**
- [ ] 진입 경로 전체 확인했나?
- [ ] 영향 범위 확인했나?

**의존성 확인**
- [ ] 새 import 필요?
- [ ] schema/모델 변경 필요?

**에러 케이스**
- [ ] 실패 시 사용자 피드백 있나?
- [ ] 네트워크 오류 처리 있나?

**작업 연결**
- [ ] 이전 BIG 미완료 있나?
- [ ] 다음 작업 선행 조건인가?

---

### 5. 진입 경로 전체 확인 (필수!)

기능 수정 시, **그 기능에 도달하는 모든 경로** 확인:

```
예시: "초대 메일 발송" 버튼 추가

질문: "이 기능에 어떻게 진입하는가?"

진입 경로:
1. 이메일 검색 → 다이얼로그 → 버튼 필요
2. 플로팅 버튼 → 다이얼로그 → 버튼 필요
3. QR 스캔 → 다이얼로그 → 버튼 필요

→ 3개 다이얼로그 모두 수정 필요!
```

**하나만 고치고 나머지 빠뜨리면 또 실수!**

---

### 6. 기대 결과 & 테스트 시나리오 (v7.9 필수!)

**지시서에 반드시 포함:**

```markdown
## 🎯 기대 결과 & 테스트 시나리오

> **CP 확인용**: 이 작업이 성공하면 어떻게 되는지

### 기대 결과
- [이 작업 완료 시 어떤 기능이 동작하는지]
- [사용자가 어떤 경험을 하게 되는지]

### 테스트 시나리오
```
1. [첫 번째 단계] → [예상 결과]
2. [두 번째 단계] → [예상 결과]
3. [세 번째 단계] → [예상 결과]
4. [최종 확인] → [성공 조건]
```
```

**왜 필요?**
- CP가 "이거 하면 뭐가 되는 거야?" 질문 방지
- 작업 목표 명확화
- 테스트 시 뭘 확인해야 하는지 명확화

---

### 7. 실시간 로그 분석 (v8.0)

**BIG_092에서 발견한 Cognito 토큰 캐싱 문제:**

```
문제 상황:
1. 초대 수락 → Lambda 완료 → role이 student로 나옴
2. 로그아웃 후 재로그인 → role이 teacher로 정상 표시

원인: Cognito 캐시된 토큰 사용
```

**해결 방법:**
```dart
// refreshAuth에 강제 새로고침 추가
await Amplify.Auth.fetchAuthSession(
  options: const FetchAuthSessionOptions(forceRefresh: true)
);
```

**실시간 로그 분석 방법:**
```
1. Sonnet: flutter run > realtime.log
2. Opus: 로그 모니터링
3. CP: "로그 확인해줘" 명령
```

**핵심 교훈:**
- Lambda 완료 ≠ Cognito 토큰 갱신
- 캐시 문제는 재로그인으로 확인 가능
- AuthState 갱신 시 forceRefresh 고려

---

## ⚠️ 컨텍스트 관리 (v8.1)

### 문제 상황 (BIG_103에서 발생)

```
✗ Opus가 직접 여러 파일 작업
✗ 빌드 로그 계속 받음
✗ 컨텍스트 kkot 찰 → Context low 경고
✗ /compact 시도 → "Conversation too long" 에러
✗ Opus 좽음 → 보고서 없음, 로그 없음
```

### 해결책: Sonnet 분할 작업

**핑수 규칙:**

1. **파일 1개씩 Sonnet에게 시키기**
   ```
   ✗ 나쁨: "3개 파일 다 만들어"
   ✓ 좋음: "파일 A 만들어" → 완료 → "파일 B 만들어" → ...
   ```

2. **스몰스텝 2~3개마다 로그 저장 + /compact**
   ```
   스텝 1 → 스텝 2 → 로그 저장 → /compact → 스텝 3 → ...
   ```

3. **Context low 경고 보이면 즉시 /compact**
   - 미루지 말고 그 자리에서 실행
   - 너무 늦으면 compact도 실패함

4. **/compact 후 확인 묻지 말고 바로 진행**
   - "진행할까요?" 질문 금지
   - compact 끝나면 바로 다음 스텝 실행

### 빅스텝 지시서에 포함할 것

```markdown
## ⚠️ 컨텍스트 관리 (필수!)

1. 스몰스텝 2~3개 완료할 때마다 로그 저장
2. 로그 저장 후 /compact 실행 → 확인 묻지 말고 바로 다음 작업
3. 파일 생성은 Sonnet한테 1개씩 시키기 (한 번에 여러 파일 X)
```

### 교훈

```
"CLI 컨텍스트가 차면 보고서도 로그도 없이 죽는다.
예방이 치료보다 낫다."
```

---

## 판단 규칙

### 에러 메시지 ≠ 실패 (v7.3)
- 에러 메시지만 보고 실패 판정 금지
- 실제 화면/동작 확인 후 판정

### ⚠️ 로그 직접 확인 필수! (v7.8)

**Opus/Desktop Claude는 보고서만 읽지 말고, 로그 파일도 직접 확인!**

```
확인할 로그:
- ai_bridge/logs/big_XXX_step_YY.log
- Flutter 콘솔 로그 (safePrint 출력)
```

**로그에서 확인할 것:**
1. 예상한 함수 호출됐나? (safePrint 메시지)
2. 데이터 올바르게 전달됐나? (user id, email 등)
3. 에러 어디서 발생? (스택트레이스)
4. API 응답 정상인가? (GraphQL response)

**Sonnet 보고서는 요약이라 세부 정보 누락됨!**

---

## 📌 버전 히스토리

| 버전 | 특징 |
|------|------|
| v6 | Opus 통합 관리 |
| v7 | 수동 모드 추가 |
| v7.1 | Opus-Sonnet 체인, 동시 호출, 보고서 중복 방지 |
| v7.2 | Sonnet 로그 파일 저장 추가 |
| v7.3 | 듀얼 디버깅 검증 규칙 강화 (에러 메시지 ≠ 실패) |
| v7.4 | 지시서 작성 규칙 추가 (구체적 지시, 빌드 판단) |
| v7.5 | 지시서 템플릿 추가 (templates/BIGSTEP_TEMPLATE.md) |
| v7.6 | 진입 경로 전체 확인 규칙 추가 |
| v7.7 | 템플릿 강화: 영향범위/의존성/에러케이스/작업연결 추가 |
| v7.8 | safePrint 로그 필수, 테스트 계정 현재 상태 확인, 로그 직접 확인 필수 |
| v7.9 | 기대 결과 & 테스트 시나리오 필수 추가 |
| v8.0 | 실시간 로그 분석 도입 (BIG_092 해결) |
| **v8.1** | **컨텍스트 관리: Sonnet 분할 작업, /compact 사용 규칙** |
